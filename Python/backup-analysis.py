import pandas as pd
from tkinter import Tk, filedialog
from tabulate import tabulate

def get_duplicates(df, col):
    """
    Helper Function for getting duplicate values within a dataframe.

    Args:
        df (dataframe): dataframe to check.
        col (String): The name of the column to be checked.

    Returns:
        df: Df of the export with rows where the column is duplicated.
    """
    df2 = df.copy()
    nan = df2[df2.isnull().any(axis=1)]
    df2.drop(nan.index, inplace=True)
    c = df2[col]
    
    invalid = df2[c.duplicated(keep=False)]

    return invalid


def get_small_values(df, col):
    """
    Helper Function for getting small values within a dataframe.

    Args:
        df (dataframe): dataframe to check.
        col (String): The name of the column to be checked.

    Returns:
        df: Df of the export with rows where the column is between 0 and 1.
    """
    c = df[col]
    invalid = df[(c > 0) & (c < 1)]

    return invalid


def calculate_invalid(df, x, y, a, b, op):
    """
    Helper Function for calculating invalid values within a dataframe.

    Args:
        df (dataframe): dataframe to check.
        x (String): The name of calculated column created to check against y.
        y (String): The name of the column being verified.
        a (String): The name of the first column to be used in the calculation.
        b (String): The name of the second column to be used in the calculation.
        op (Lambda): The operation to be performed on the two columns a and b.

    Returns:
        df: Df of the export with rows where the calculated column does not match the expected value.
    """
    # copy df and create calculated column
    df2 = df.copy()
    df2[x] = op(df2[a], df2[b])

    #  check for invalid values
    mismatch = (df2[y] - df2[x]).abs() > 1e-2
    invalid = df2[mismatch].copy()

    #  insert calculated column next to the expected column
    cols = list(invalid.columns)
    y_index = cols.index(y)
    cols.insert(y_index + 1, cols.pop(cols.index(x)))

    return invalid[cols]


def check_percent_complete(df):
    """
    Checks for rows where the % Complete is not between 0 and 100.

    Args:
        df (dataframe): Df of the export.

    Returns:
        df: Df of the export with rows where % Complete is not between 0 and 100.
    """
    perc_complete = df["% Complete"]
    invalid = df[(perc_complete < 0) | (perc_complete > 1)]
    return invalid


def check_nan(df):
    """
    Checks for rows where NaN values are present.
    Drops the rows from the df.

    Args:
        df (dataframe): Df of the export.

    Returns:
        df: Df of the export with rows where NaN values are present.
    """
    nan = df[df.isnull().any(axis=1)]
    # df.drop(nan.index, inplace=True)
    return nan


def check_empty_description(df):
    """
    Checks for rows where the Work Release # number is not present.
    Drops the rows from the df.

    Args:
        df (dataframe): Df of the export.

    Returns:
        df: Df of the export with rows where the Work Release # number is not present.
    """
    missing = df[df["Description"].isnull()]
    # df.drop(missing.index, inplace=True)
    return missing


def select_file():
    """
    Creates a file dialog to select an Excel file.

    Raises:
        Exception: If no file is selected.

    Returns:
        String: Filepath of the export.
    """
    Tk().withdraw()  # Hide the root window
    file_path = filedialog.askopenfilename(
        title="Select Excel File",
        filetypes=[("Excel files", "*.xlsx *.xls")],
    )
    if not file_path:
        raise Exception("No file selected.")
    return file_path


def main():
    """
    Analyzes the export file generated by the backup-generation.py script.
    """
    file_path = select_file()
    df = pd.read_excel(file_path, dtype={"Description": str})

    print("Loaded file:", file_path)

    missing = check_empty_description(df)
    nan = check_nan(df)
    invalid_perc_complete = check_percent_complete(df)
    invalid_tpd_perc_complete = calculate_invalid(
        df,
        "Calculated TPD (TCV * %C)",
        "Total Progress to Date",
        "Total Contract Value",
        "% Complete",
        lambda a, b: a * b,
    )
    invalid_tpd_prev_curr = calculate_invalid(
        df,
        "Calculated TPD (PB + CB)",
        "Total Progress to Date",
        "Previously Billed",
        "Current Billing",
        lambda a, b: a + b,
    )
    invalid_tcv = calculate_invalid(
        df,
        "Calculated TCV (TPD + Balance)",
        "Total Contract Value",
        "Total Progress to Date",
        "Balance",
        lambda a, b: a + b,
    )

    small_tcv = get_small_values(df, "Total Contract Value")
    small_tpd = get_small_values(df, "Total Progress to Date")
    small_pb = get_small_values(df, "Previously Billed")
    small_cb = get_small_values(df, "Current Billing")
    small_balance = get_small_values(df, "Balance")

    small_values = pd.concat(
        [
            small_tcv,
            small_tpd,
            small_pb,
            small_cb,
            small_balance,
        ]
    ).drop_duplicates()

    duplicated_wrs = get_duplicates(df, "Description")
    
    if not missing.empty:
        print("\nPrinting rows where Description is missing:")
        print(tabulate(missing, headers="keys", tablefmt="psql"))

    if not nan.empty:
        print("\nPrinting rows where NaN values are present:")
        print(tabulate(nan, headers="keys", tablefmt="psql"))

    if not invalid_perc_complete.empty:
        print("\nPrinting rows where % Complete is invalid: \n")
        print(tabulate(invalid_perc_complete, headers="keys", tablefmt="psql"))

    if not invalid_tpd_perc_complete.empty or not invalid_tpd_prev_curr.empty:
        print("\nPrinting rows where Total Progress to Date is invalid: \n")
        if not invalid_tpd_perc_complete.empty:
            print(tabulate(invalid_tpd_perc_complete, headers="keys", tablefmt="psql"))
        if not invalid_tpd_prev_curr.empty:
            print(tabulate(invalid_tpd_prev_curr, headers="keys", tablefmt="psql"))

    if not invalid_tcv.empty:
        print("\nPrinting rows where Total Contract Value is invalid: \n")
        print(tabulate(invalid_tcv, headers="keys", tablefmt="psql"))

    if not small_values.empty:
        print("\nPrinting rows where values are too small: \n")
        print(tabulate(small_values, headers="keys", tablefmt="psql"))

    if not duplicated_wrs.empty:
        print("\nPrinting rows with duplicate WRs: \n")
        print(tabulate(duplicated_wrs, headers="keys", tablefmt="psql"))
        
    reporting_values = {
        "Missing Description": missing,
        "NaN Values": nan,
        "Invalid % Complete": invalid_perc_complete,
        "Invalid TPD (% Complete)": invalid_tpd_perc_complete,
        "Invalid TPD (PB + CB)": invalid_tpd_prev_curr,
        "Invalid TCV": invalid_tcv,
        "Small Values": small_values,
        "Duplicate WRs": duplicated_wrs,
    }

if __name__ == "__main__":
    main()
